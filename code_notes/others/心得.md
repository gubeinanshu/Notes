以下是我在读《软件测试》这本书时候的一些心得，主要是对测试方面的知识点。下面将对书中的内容进行简单的介绍和总结，以及一些自己认为重要的概念的摘要，同时附上根据自己的实际经验和思考写一点对内容的想法和理解。在最后，将会附上自己对软件测试这个过程的想法和总结。

# 一、测试概述

首先描述一下几个概念

1. 错误（error）：人类会犯错误。
2. 缺陷（fault）：缺陷是错误的结果。
3. 失效（failure）：当缺陷执行时会发生失效。
4. 事故（incident）：当出现失效时，可能会也可能不会呈现给用户。事故说明出现了与失效类似的情况，警告用户注意所出现的失效。
5. 测试（test）：测试显然要处理错误、缺陷、失效和事故。测试两个目标：找出失效，或演示正确的执行。
6. 测试用例（test case）：测试用例有一个标识，并与程序行为有关。测试用例还有一组输入和一个预期输出表。

## 1.1 测试的基本方法

有两种基本方法可以用来标识测试用例

* 功能性测试
* 结构性测试

### 1.1.1 功能性测试

> 基本观点：任何程序都可以看作是将从输入定义域取值映射到输出值域的函数。

下面通俗的描述一下，功能性测试又被称为黑盒测试，简言之，就是测试人员不知道程序是怎么实现的，具体实现对测试人员不可见，也不关注它是怎么实现的。我们只关心给出一个输入，它将输出什么，然后检查输出是否是被预期的，或者程序是否执行不正常。

### 1.1.2 结构性测试

又称为白盒测试，测试人员将能看到源码，能够对代码逻辑进行测试，包括单条语句，分支，循环等。根据不同的要求，对代码逻辑测试的覆盖程度有不同的要求。

**两种方法有自己的优点和不足，两种方法的有机结合，才能更好的完成测试工作**


## 1.2 错误与缺陷分类

这里仅列出基本类别：

1. 输入/输出缺陷
2. 逻辑缺陷
3. 计算缺陷
4. 接口缺陷
5. 数据缺陷


# 二、功能性测试

功能性测试包括以下几种方式

* 边界值测试
* 等价类测试
* 基于决策表的测试

下面将对这几种测试方式进行介绍和总结

## 2.1 边界值测试

1. 边界值分析  
基本思想：使用在最小值、略高于最小值、正常值、略低于最大值、和最大值处取输入变量值
2. 健壮性测试  
除开上面的五个边界值分析取值，还要通过采用一个略超过最大值的取值，以及一个略小于最小值的取值，看看超过极值时系统会有什么表现。
3. 最坏情况测试  
基本思想：对每个变量，**首先进行包含最小值**、略高于最小值、正常值、略低于最大值和最大值五元素集合的测试，然后对这些集合进行笛卡尔积计算，用以生成测试用例。
4. 特殊值测试  
特殊值测试大概是运用的最广泛的一种功能性测试。该方式由测试人员的领域知识和经验直接指定测试用例，找到特殊值来测试，主观性比较强，因此特别依赖测试人员的能力，不过使用时常能够更加有效的发现缺陷。
5. 随机测试  
基本思想：使用随机数生成器选出测试用例值。随机测试可以避免出现测试偏见。

**感想：** 以前自己做acm的时候，就遇到很多边界值不通过的情况，常见的有输入为0，-1，1，或者数字大小超过long long类型的情况，或者一些特别的输入的组合，前面的情况可以通过边界值分析可以分析出，通过反复的执行，一般也能很快的找到，而特殊的组合的情况很多时候依托于自己的灵感了，通过反复的执行，进行分析，得出特殊输入，这就是特殊值测试了。之前为第三方提供过接口，为他人提供接口，别人正常调用当然是没有问题的，但是调用的时候总是会存在问题，写接口就需要尽量捕获所有可能的错误情况，然后反馈给调用方，例如参数错误，格式错误，验证错误，错误调用导致的异常等等，此时该接口的就需要进行健壮性测试，为第三方提供完善的错误信息。


## 2.2 等价类测试

> 基本思想：通过每个等价类中的一个元素标识测试用例，广泛选择等价类，可以大大降低测试用例之间的冗余。

下面是网络检索到的解释，更加通俗一点  
> 等价类划分是一种典型的黑盒测试方法，等价类测试方法是把所有可能的输入数据，即程序的输入域划分成若干部分，然后从每一部分中选取少数有代表性的数据作为测试用例。使用等价类划分方法设计测试用例要经历划分等价类（列出等价类表）和选取测试用例两步。

由此可以知道，等价类测试方法减少了测试数据的冗余，减少测试用例，减少了重复测试

下面是等价类测试中几个方式

1. 弱一般等价类测试  
基本思想：基于单缺陷假设，通过使用一个测试用例中的每个等价类（区间）的一个变量实现。
2. 强一般等价类测试  
基本思想：基于多缺陷假设，需要等价类笛卡尔积的每个元素对应的测试用例
3. 弱健壮等价类测试  
基本思想：基于单缺陷假设，考虑了无效值的情况。对于有效输入，使用每个有效类的一个值；对于无效输入，测试用例将拥有一个无效值，并保持其余的值都是有效的。
4. 强健壮等价类测试  
基本思想：基于多缺陷假设，考虑了无效值的情况。同样从所有等价类笛卡尔积的每个元素中获得测试用例。

**感想：** 等价类测试可以有效减少冗余测试数据，基于严谨的输入输出结果，可以减少测试工作。相对于边界测试，覆盖了更多的一般情况。同时等价类的强形式测试的更加全面。对于该测试方式，在实际中感触较少，但对与无效值的测试非常有必要，程序运行中可能参数传入None的时候，很可能导致程序出现异常。



## 2.3 基于决策表的测试

*这一章看的不是很明白，下面是网络检索到的，解释的比较通俗，比较清楚。该节内容参考了：[黑盒测试(三)--------基于决策表的测试](https://blog.csdn.net/A00553344/article/details/1834664)* 

在一些数据处理问题中，某些操作是否实施依赖于多个逻辑条件的取值。在这些逻辑条件取值的组合所构成的多种情况下，分别执行不同的操作。处理这类问题的一个非常有力的分析和表达工具是判定表，或称决策表。  
所有功能性测试方法中，基于决策表的测试方法是最严格的，决策表在逻辑上是严密的。


![image](http://s1.sinaimg.cn/orignal/538efac11806665ea6930)


* 条件桩：列出了问题的所有条件。
* 动作桩：列出了问题规定可能采取的操作。
* 条件项：列出针对它所列条件的取值，在所有可能情况下的真假值。 
* 动作项：列出在条件项的各种取值情况下应该采取的动作。
* 规则：任何一个条件组合的特定取值及其相应要执行的操作。


决策表的建立步骤：

1. 确定规则个数；
2. 列出所有的条件桩和动作桩；
3. 填入条件项；
4. 填入动作桩和动作项，得到初始判定表；
5. 化简，合并相似规则；
6. 依据判定表，选择测试数据，设计测试用例。

使用决策表测试的Beizer条件：

* 规格说明以决策表形式给出，或是很容易转换成判定表；
* 条件的排列顺序不会也不应影响执行哪些动作；
* 规则的排列顺序不会也不应影响执行哪些动作；
* 每当某一规则的条件已经满足，并确定要执行的动作后，不必检验别的规则；
* 如果某一规则得到满足要执行多个动作，这些动作的执行顺序无关紧要。

规则及规则合并:

* 规则：任何一个条件组合的特定取值及其相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。显然,判定表中列出多少组条件取值,也就有多少条规则,既条件项和动作项有多少列。
* 化简：就是规则合并有两条或多条规则具有相同的动作，并且其条件项之间存在着极为相似的关系。

**感想：** 之前也没有做过决策表这样的测试，可以感觉到采用这种方式，得到严格的测试的结果的同时需要投入更多的精力和时间，决策表的迭代，和条件及行动的分析等都需要时间比较强的逻辑思维。


# 三、结构性测试

结构性测试方法的特征就是他们是基于被测程序的源代码，而不是基于定义。
结构性测试包括以下几种方式

* 路径测试
* 数据流测试

下面将对这两种测试方式进行介绍和总结


## 路径测试

书上讲的理论性比较强，这里按照自己的理解描述一下。

基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每个可执行语句至少执行一次。
简言之，就是设计合理的测试用例来让程序代码所有的分支都会执行一遍。

根据测试覆盖程度，大致分为下面几个：

* 基本路径测试：在程序控制图的基础上，通过分析控制构造的环行复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的每一个可执行语句至少执行一次。
* 语句覆盖：语句覆盖就是设计足够多的测试用例，运行被测试程序，使得每一条可执行语句至少执行一次。可以说语句覆盖是最弱的逻辑覆盖准则。
* 判定覆盖：也称为分支覆盖。设计足够多的测试用例，运行所测程序，使程序中每个判断的取真分支和取假分支至少执行一次；但是不能对判断条件进行检查。
* 条件覆盖：设计足够多的测试用例，运行所测程序，使程序中每个判断的每个条件的每个可能取值至少执行一次。
* 判定-条件覆盖：设计足够多的测试用例，运行所测程序，使程序中每个判断的每个条件的所有可能取值至少执行一次，并且每个可能的判断结果也至少执行一次。
* 判定-条件覆盖从表面来看，它测试了所有条件的取值，但是实际上某些条件掩盖了另一些条件。因此，采用判定-条件覆盖，逻辑表达式中的错误不一定能够查出来了。
* 条件组合覆盖：设计足够多的测试用例，运行所测程序，使程序中每个判断的所有可能的条件取值组合至少执行一次。
* 路径测试：就是设计足够多的测试用例，覆盖被测试对象中的所有可能路径。

**感想：** 自己其实平时不会做这样的逻辑测试，更多的时候是问题出现，然后打断点debug查看变量和执行语句，大概这个时候有点测试逻辑的意思吧。


## 数据流测试

数据流测试指关注变量接受值的点和使用（或引用）这些值的点的结构性测试形式。数据流测试用作路径测试后的“真实性检查”。

两种基本方法：

1. 一组基本定义和一种统一的测试覆盖指标结构测试
2. 基于“程序片”的概念的测试

**感想：** 这个概念不知道怎么用自己的话描述，这节先这样子。

# 四、集成与系统测试

* 集成测试：是在软件系统集成过程中所进行的测试，其主要目的是检查软件单位之间的接口是否正确。它根据集成测试计划 ，一边将模块或其他单位组合成越来越大的系统，一边运行该系统，以分析所组成的系统是否正确，各个组成部分是否合拍。集成测试的策略主要有自顶向下和自底向上两种。也可以理解为在软件设计单元、功能模块组装、集成为系统时，对应用系统的各个部件（软件单元、功能模块接口、连接等）进行的联合测试，以决定他们能否在一起共同工作，部件可以是代码块、独立的应用、网络上的客户端或服务器端程序。 

* 系统测试：系统测试是基于软件需求说明书的黑盒测试，是对已经集成好的软件系统进行彻底的测试，以验证软件系统的正确性和性能等满足其规约所指定的要求，检查软件的行为和输出是否正确，并非一项简单的任务，被称为测试的“先知者问题”。因此，系统测试应该按照测试计划进行，其输入、输出和其他的动态运行行为应该与软件规约进行对比。软件系统测试的方法很多，主要有功能测试，性能测试，随机测试等。
 
* 交互测试：交互测试根据以用户体验为基础进行，在系统满足产品定义的前提下，对两个或两个以上的功能进行互动的一种机制，根据事件的优先级，检查高优先级事件是否可以打断当前事件。交互测试还包含对声音交互的检查，检查对同时发声的处理机制。


# 五、面向对象的测试

* 类测试
* 面向对象的集成测试
* GUI测试
* 面向对象的系统测试


# 心得

接下来就根据自己的经验和读书过程中的一些感受。
首先，一个好的测试工作是非常重要的，重要程度不亚于开发，功能测试可能还好，但是逻辑测试同样要求测试人员能够看懂源码，而能力强的测试人员，能够根据代码逻辑提出意见。测试工作对测试人员的能力要求也比较高，可能很多时候测试人员的经验很重要。

自己在项目开发中也没有经历过完整的测试工作，也就是功能测试通不通，调试bug。看了集成测试后，感到将一个项目分割模块化是非常有必要的，不仅是为了开发工作的分解，方便模块维护，同时也是方便测试，定位错误。

测试开始要分析程序的输入输出，功能模块，外部条件，明确的给出测试的条件和动作（行为），分析过程的规范化，再以程序流程图等图辅助分析记录，以期得到完善的测试结果。

总的来说，测试工作是项目开发流程中非常重要的一环，对项目的优秀质量有着推进作用。

感谢各位阅读！








